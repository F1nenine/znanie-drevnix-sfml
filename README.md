# Великая Древнерусская Графическая Библиотека В††

___

![Лого](https://sun9-35.userapi.com/impg/JMeZbK2RtwcUHV8PLS5Lizg8QRJ3cOUpons0IA/ImYNJDVqCh0.jpg?size=506x330&quality=96&sign=63f7c2f5af0678b205c0e48296ae4106&type=album)

Наконец язык В†† был найден и&nbsp;теперь доступен русам для написания кода на&nbsp;нём. Язык только нашли, поэтому открыты ещё не&nbsp;все возможности древней русской силы.
Больше материалов о&nbsp;языке смотрите на&nbsp;YouTube канале [Ватага](https://www.youtube.com/@VatagaRUS)
[Исходная библиотека](https://github.com/KanatnikovMax/znanie-drevnix)

Данное ответление создано для того, чтобы работы с басурманским SFML была более родной.
___ 

## Как начать писать?
Для начала нужно установить на свой компьютер последнюю версию языка.
- необходимо скачать содержимое папки [header](https://github.com/F1nenine/znanie-drevnix-sfml/tree/main/header);
- далее нужно создать проект на языке C++, под видом которого долгие годы прятался В††. В папку этого проекта, в которой находятся файлы сборки, переносим наши файлы;
- после в папку проекта требуется скачать [SFML 2.6.2](https://www.sfml-dev.org/download/sfml/2.6.2/);
- скинуть библиотеку SFML в папку где находятся заголовочные файлы, папка должна называться строго __"SFML"__;
- подключить все зависимости SFML в свойствах проект в Visual Studio 2022, [наиболее простой гайд](https://habr.com/ru/articles/703500/);
- теперь для того, чтобы начать писать, нужно только подключить заголовочный файл при помощи первой и последней для вашего кода ящерской команды 
```C++
#include "Графильница_крест_крест.h"
```
- пишем код во славу Руси!

___ 

## В чём суть реализации?
Основная реализация в заголовочном файле __"Ве_крест_крест.h"__ это использование #define и using
```C++
#define внедрить using
внедрить целина = int;
```
В чём проблема?
У нас целый класс, со своими методами и если создать переменную и попытаться вызвать метод, переопределённый через #define, его не будет в подсказках!
Это не прикольно, но лёгкая реализация. ПОЭТОМУ МЫ СТРАДАЕМ. Ой.

```C++
династия ОкноСозерцанья : народный sf::RenderWindow{}
```
Что это? Это оболочка для класса sf::RenderWindow, названная ОкноСозерцанья, который является дочерним классом sf::RenderWindow, а значит он наследует все существующие методы, которые отображаются у нас в подсказках!

```C++
династия ОкноСозерцанья : народный sf::RenderWindow{
народный:
    // Конструкторы
    ОкноСозерцанья() : sf::RenderWindow() {}

    ОкноСозерцанья(sf::WindowHandle ручка, приказ_княжий sf::ContextSettings & настройки = sf::ContextSettings())
        : sf::RenderWindow(ручка, настройки) {}

    ОкноСозерцанья(sf::VideoMode видеоРежим, приказ_княжий sf::String & заглавие, sf::Uint32 стиль = sf::Style::Default,
        приказ_княжий sf::ContextSettings & настройки = sf::ContextSettings())
        : sf::RenderWindow(видеоРежим, заглавие, стиль, настройки) {}

    ~ОкноСозерцанья() = базированно;

    розсуд открыто() приказ_княжий { воздать isOpen(); }
```
Конструкторы переопределяем все, для меньших проблем. Метод открыто(), является обёрткой, внутри которого "конфета" под названием вывов метода isOpen(). 
__Требуется учитывать что возвращает метод и какие параметры он принимает.__

После переноса всех методов. ТЕОРЕТИЧЕСКИ можно сделать наследование царским, что оставит в подсказках только НАШИ методы, убрав басурмаский язык, но надо быть уверенным что всё перенесено.
```C++
династия ОкноСозерцанья : царский sf::RenderWindow{}
```
Вот такие пироги!

___ 

## Почему SFML 2.6.2?
Всё просто. У меня не получилось запустить SFML&nbsp;3.x.x. А так же лень, пока что, разбираться в изменениях. 
Может быть потом будет перенос на SFML&nbsp;3.x.x, если автора не настигнет реальность и свежий воздух, ну или выйдет SFML 4.x.x.

___ 

## Примеры программ
Программы, написанные на&nbsp;В††. Их исходный код доступен для каждого руса в&nbsp;папке [examples](https://github.com/KanatnikovMax/znanie-drevnix/tree/main/examples)
Программы графильницы доступны в папке [examples](https://github.com/F1nenine/znanie-drevnix-sfml/tree/main/examples)
